#pragma once
#include <stdint.h>

#define TREX_PROTO_VERSION 2

#define DROP_READER_UNKNOWN 255

// --- enums ---
enum class StationType : uint8_t { TREX=0, LOOT=1, DROP=2 };
enum class LightState  : uint8_t { GREEN=0, RED=1, YELLOW=2 };

enum class MsgType : uint8_t {
  HELLO=1, HEARTBEAT=2,
  STATE_TICK=10, GAME_OVER=11, SCORE_UPDATE=12, STATION_UPDATE=13, GAME_START=14, ROUND_STATUS=15,
  LOOT_HOLD_START=20, LOOT_HOLD_ACK=21, LOOT_TICK=22, LOOT_HOLD_STOP=23, HOLD_END=24,
  DROP_REQUEST=30, DROP_RESULT=31,
  CONFIG_UPDATE=40,
  OTA_STATUS=50,
  BONUS_UPDATE=60
};

#pragma pack(push,1)

// -------- header ----------
struct MsgHeader {
  uint8_t  version;       // = TREX_PROTO_VERSION
  uint8_t  type;          // MsgType
  uint8_t  srcStationId;  // 0=T-Rex
  uint8_t  flags;         // reserved
  uint16_t payloadLen;    // bytes after header
  uint16_t seq;           // per-sender sequence
};

// -------- common ----------
struct TrexUid { uint8_t len; uint8_t bytes[10]; };

struct HelloPayload {
  uint8_t     stationType;   // StationType
  uint8_t     stationId;
  uint8_t     fwMajor, fwMinor;
  uint8_t     wifiChannel;   // for ESP-NOW alignment
  uint8_t     mac[6];
};

struct StateTickPayload { uint8_t state; uint32_t msLeft; };

struct ScoreUpdatePayload { uint32_t teamScore; };

struct StationUpdatePayload { uint8_t stationId; uint16_t inventory; uint16_t capacity; };

// Special value meaning "apply to all stations"
#define GAMEOVER_BLAME_ALL 0xFF

// If payloadLen == 1 => legacy (no blameSid) -> treat as GAMEOVER_BLAME_ALL.
// If payloadLen >= 2 => second byte is blameSid.
struct GameOverPayload {
  uint8_t reason;    /* GameOverReason */
  uint8_t blameSid;  /* station id that caused end; 0xFF = ALL (optional; see payloadLen) */
};

// -------- loot flow ----------
struct LootHoldStartPayload { uint32_t holdId; TrexUid uid; uint8_t stationId; };

struct LootHoldAckPayload {
  uint32_t holdId;
  uint8_t  accepted;     // 1=yes, 0=no
  uint8_t  rateHz;       // usually 1
  uint8_t  maxCarry;
  uint8_t  carried;
  uint16_t inventory;
  uint16_t capacity;
  uint8_t  denyReason;   // HoldEndReason if accepted=0
};

struct LootTickPayload { uint32_t holdId; uint8_t carried; uint16_t inventory; };

struct LootHoldStopPayload { uint32_t holdId; };

struct HoldEndPayload { uint32_t holdId; uint8_t reason; /* HoldEndReason */ };

// -------- drop flow ----------
struct DropRequestPayload { TrexUid uid; uint8_t readerIndex; /*0..3*/ };

struct DropResultPayload { uint16_t dropped; uint32_t teamScore; uint8_t readerIndex; };

struct BonusUpdatePayload { uint32_t mask; };

// -------- OTA trigger & status ----------
struct ConfigUpdatePayload {
  uint8_t   stationType;     // 0 = all, else StationType (e.g., LOOT)
  uint8_t   targetId;        // 0 = all IDs of that type, else specific stationId
  char      otaUrl[128];     // "" = no OTA; else http://.../file.bin
  uint32_t  campaignId;      // generated by T-Rex
  uint8_t   expectMajor;     // optional (0=ignore)
  uint8_t   expectMinor;     // optional (0=ignore)
  // (room for future config fields)
};

enum class OtaPhase : uint8_t { ACK=1, STARTING=2, FAIL=3, SUCCESS=4 };

struct OtaStatusPayload {
  uint8_t   stationType;     // StationType::LOOT
  uint8_t   stationId;
  uint32_t  campaignId;
  uint8_t   phase;           // OtaPhase
  uint8_t   error;           // 0=OK, 1=WiFi, 2=HTTP, 3=NoLen, 4=Write, 5=Verify
  uint8_t   fwMajor;         // running version at time of send
  uint8_t   fwMinor;
  uint32_t  bytes;           // bytes downloaded so far (SUCCESS sends total)
  uint32_t  total;           // total if known else 0
};

struct RoundStatusPayload {
  uint8_t  roundIndex;
  uint8_t  reserved;      // keep alignment tidy
  uint16_t _pad;
  uint32_t roundStartScore;  // teamScore at round start
  uint32_t roundGoalAbs;     // absolute teamScore to reach this round
  uint32_t msLeftRound;      // optional, informational
};

#pragma pack(pop)
